# CPP_2GIS_Hackathon_april2022
Task and solution
# Coding Test: data search

Для быстрого запуска проекта присутствуют стадии сборки all, clean, test, timetest, example, gcov_report

Стадии
- all запускает демонстрационную программу с вводом параметров из консоли.
- clean удаляет файлы, которые создавались при предыдущих сборках и тестах
- test проводит следующие виды тестов:
  - юнит-тесты
  - интеграционные тесты (проверка на соответствие примеру из задания с помощью bash-скрипта)
  - тесты на сравнение двух алгоритмов по времени исполнения.
- gcov_report - создает html отчет о том, какие части кода вызывались при тестах.


В проекте реализованы 2 алгоритма поиска подстрок в соответствии с условиями задачи.

Первый алгоритм реализован алгоритмом в тремя уровнями вложенности циклов while.
Второй алгоритм ограничивается двумя уровнями.

Разница во времени работы алгоритмов незначительная, в пользу второго алгоритма.

Для хранения данных в обоих алгоритмах используется контейнер Vector<int8_t>

Краткое описание алгоритмов:

## 1.  findTheSequence()

Получаем токен искомого слова, скопировав его от начала до позиции threshold. Затем первую букву этого слова (первый байт) ищем в векторе с использованием стандартного метода find(). После того как мы нашли букву мы копируем в отдельный токен все байты, начиная с найденного до threshold.
Скопированные векторы сравниваются с помощью перегруженного оператора ==. Если совпадение нашлось, то мы делаем расширение наших токенов - искомый увеличивается на один (если есть такая возможность) и аналогично скопированный из haystack тоже расширяется на один элемент.

После этого элементы снова сравниваются. Если оказалось, что на предыдущем уровне thresold было совпадение, а на этом нет, то выводим на экран сообщение о том, что поиски увенчались успехом.

## 2.  findTheSequence2()

Токен искомого слова получаем аналогично предыдущему. Но мы сразу сравниваем его с первыми threshold байтами нашего haystack. Если совпадения нет, то мы начинаем "сдвигать" наш искомый токен по needle на одну позицию вправо. Если ни одного совпадения на уровне по умолчанию не достигнуто, то мы отрезаем последний байт и начинаем перебирать аналогичным образом совпадения для второго.
Сдвигаемся так по haystack, пока либо не достгнем его конца, либо пока не наткнемся на совпадение. Если мы достигли совпадения, то начинаем увеличивать значения токенов, добавляя по 1 байту из последовательности haystack, пока наше совпадение продолжается. Как только мы достигли несовпадения, то это показатель того, что предыдйщий уровень threshold был верен, и выводим сообщение о том, что совпадение найдено.

Примечания и выводы:
1. В проекте использовались стандартные контейнеры, что могло сказаться на производительности проекта в целом. Использование массивов типа char может ускорить работу каждого из алгоритмов.
2. Несмотря на наличие оптимизированного метода find  в первом алгоритме тройная вложенность циклов работает хуче, чем двойная. Особенно это заметно на файлах большого размера
3. Алгоритмы создавались под задачу и не являются какой-либо реализацией популярных или доказавших свою эффективность алгоритмов.
